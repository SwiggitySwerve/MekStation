/**
 * Unit Card Data Aggregation Service
 *
 * Aggregates unit data into a standardized format for display in unit cards.
 * Supports all unit types: BattleMechs, Vehicles, Aerospace, Battle Armor, Infantry, ProtoMechs.
 *
 * @spec openspec/changes/add-unit-card-view/proposal.md
 */

import { TechBase } from '@/types/enums/TechBase';
import { RulesLevel } from '@/types/enums/RulesLevel';
import { WeightClass } from '@/types/enums/WeightClass';
import { UnitType } from '@/types/unit/BattleMechInterfaces';
import {
  IBaseUnit,
  isGroundUnit,
  isAerospaceUnit,
  isSquadUnit,
} from '@/types/unit/BaseUnitInterfaces';
import { WeaponCategory, WeaponRanges } from '@/types/equipment/weapons/interfaces';

// =============================================================================
// Unit Card Data Interfaces
// =============================================================================

/**
 * Weapon summary for display in unit cards
 */
export interface IWeaponSummary {
  readonly name: string;
  readonly category: WeaponCategory;
  readonly damage: number | string;
  readonly heat: number;
  readonly ranges: WeaponRanges;
  readonly count: number;
  readonly location?: string;
  readonly isRearMounted?: boolean;
}

/**
 * Movement summary for display in unit cards
 */
export interface IMovementSummary {
  /** Walk/Cruise MP */
  readonly walkMP: number;
  /** Run/Flank MP */
  readonly runMP: number;
  /** Jump MP (0 if none) */
  readonly jumpMP: number;
  /** Safe thrust (aerospace only) */
  readonly safeThrust?: number;
  /** Max thrust (aerospace only) */
  readonly maxThrust?: number;
  /** UMU MP (squad units only) */
  readonly umuMP?: number;
  /** Jump jet type if applicable */
  readonly jumpJetType?: string;
  /** Movement enhancements (MASC, Supercharger, TSM) */
  readonly enhancements?: readonly string[];
}

/**
 * Armor/Structure summary for display in unit cards
 */
export interface IArmorStructureSummary {
  /** Total armor points allocated */
  readonly totalArmor: number;
  /** Maximum possible armor for this unit */
  readonly maxArmor: number;
  /** Armor percentage (0-100) */
  readonly armorPercentage: number;
  /** Armor type name */
  readonly armorType: string;
  /** Internal structure type name */
  readonly structureType: string;
  /** Total structure points */
  readonly totalStructure: number;
  /** Structural integrity (aerospace only) */
  readonly structuralIntegrity?: number;
}

/**
 * Heat summary for display in unit cards
 */
export interface IHeatSummary {
  /** Total heat generated by all weapons (alpha strike) */
  readonly totalHeatGenerated: number;
  /** Heat dissipation capacity */
  readonly heatDissipation: number;
  /** Net heat (generated - dissipated) */
  readonly netHeat: number;
  /** Heat sink type */
  readonly heatSinkType: string;
  /** Total heat sink count */
  readonly heatSinkCount: number;
  /** Is heat neutral when firing all weapons */
  readonly isHeatNeutral: boolean;
}

/**
 * Equipment summary item
 */
export interface IEquipmentSummaryItem {
  readonly name: string;
  readonly category: string;
  readonly weight: number;
  readonly criticalSlots: number;
  readonly location?: string;
  readonly count: number;
}

/**
 * Critical slot summary per location
 */
export interface ICriticalSlotSummary {
  readonly location: string;
  readonly totalSlots: number;
  readonly usedSlots: number;
  readonly freeSlots: number;
  readonly items: readonly string[];
}

/**
 * Complete unit card data interface
 * Contains all aggregated data needed to render any unit card variant
 */
export interface IUnitCardData {
  // === Identity ===
  readonly id: string;
  readonly name: string;
  readonly chassis: string;
  readonly model: string;
  readonly variant?: string;
  readonly clanName?: string;

  // === Classification ===
  readonly unitType: UnitType;
  readonly unitTypeName: string;
  readonly techBase: TechBase;
  readonly techBaseName: string;
  readonly rulesLevel: RulesLevel;
  readonly rulesLevelName: string;
  readonly era?: string;
  readonly year: number;

  // === Physical ===
  readonly tonnage: number;
  readonly weightClass: WeightClass;
  readonly weightClassName: string;

  // === Combat Values ===
  readonly battleValue: number;
  readonly pointValue?: number;
  readonly cost?: number;

  // === Summaries ===
  readonly movement: IMovementSummary;
  readonly armorStructure: IArmorStructureSummary;
  readonly heat: IHeatSummary;
  readonly weapons: readonly IWeaponSummary[];

  // === Expanded Details ===
  readonly equipment: readonly IEquipmentSummaryItem[];
  readonly criticalSlots: readonly ICriticalSlotSummary[];
  readonly quirks: readonly string[];
  readonly notes?: string;
  readonly fluff?: {
    readonly overview?: string;
    readonly capabilities?: string;
    readonly deployment?: string;
    readonly history?: string;
  };

  // === Unit-Type Specific ===
  /** Squad size for Battle Armor/Infantry */
  readonly squadSize?: number;
  /** Fuel points for Aerospace */
  readonly fuel?: number;
  /** Configuration for Mechs (Biped, Quad, etc.) */
  readonly configuration?: string;
  /** Is this an OmniMech/OmniVehicle */
  readonly isOmni?: boolean;
}

// =============================================================================
// Tech Base Name Mapping
// =============================================================================

const TECH_BASE_NAMES: Record<TechBase, string> = {
  [TechBase.INNER_SPHERE]: 'IS',
  [TechBase.CLAN]: 'Clan',
};

// =============================================================================
// Rules Level Name Mapping
// =============================================================================

const RULES_LEVEL_NAMES: Record<RulesLevel, string> = {
  [RulesLevel.INTRODUCTORY]: 'Intro',
  [RulesLevel.STANDARD]: 'Standard',
  [RulesLevel.ADVANCED]: 'Advanced',
  [RulesLevel.EXPERIMENTAL]: 'Experimental',
};

// =============================================================================
// Weight Class Name Mapping
// =============================================================================

const WEIGHT_CLASS_NAMES: Record<WeightClass, string> = {
  [WeightClass.ULTRALIGHT]: 'Ultralight',
  [WeightClass.LIGHT]: 'Light',
  [WeightClass.MEDIUM]: 'Medium',
  [WeightClass.HEAVY]: 'Heavy',
  [WeightClass.ASSAULT]: 'Assault',
  [WeightClass.SUPERHEAVY]: 'Superheavy',
};

// =============================================================================
// Unit Type Name Mapping
// =============================================================================

const UNIT_TYPE_NAMES: Record<UnitType, string> = {
  [UnitType.BATTLEMECH]: 'BattleMech',
  [UnitType.OMNIMECH]: 'OmniMech',
  [UnitType.INDUSTRIALMECH]: 'IndustrialMech',
  [UnitType.PROTOMECH]: 'ProtoMech',
  [UnitType.VEHICLE]: 'Vehicle',
  [UnitType.VTOL]: 'VTOL',
  [UnitType.AEROSPACE]: 'Aerospace',
  [UnitType.CONVENTIONAL_FIGHTER]: 'Conv. Fighter',
  [UnitType.SMALL_CRAFT]: 'Small Craft',
  [UnitType.DROPSHIP]: 'DropShip',
  [UnitType.JUMPSHIP]: 'JumpShip',
  [UnitType.WARSHIP]: 'WarShip',
  [UnitType.SPACE_STATION]: 'Space Station',
  [UnitType.INFANTRY]: 'Infantry',
  [UnitType.BATTLE_ARMOR]: 'Battle Armor',
  [UnitType.SUPPORT_VEHICLE]: 'Support Vehicle',
};

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Get tech base display name
 */
export function getTechBaseName(techBase: TechBase): string {
  return TECH_BASE_NAMES[techBase] ?? 'Unknown';
}

/**
 * Get rules level display name
 */
export function getRulesLevelName(rulesLevel: RulesLevel): string {
  return RULES_LEVEL_NAMES[rulesLevel] ?? 'Unknown';
}

/**
 * Get weight class display name
 */
export function getWeightClassName(weightClass: WeightClass): string {
  return WEIGHT_CLASS_NAMES[weightClass] ?? 'Unknown';
}

/**
 * Get unit type display name
 */
export function getUnitTypeName(unitType: UnitType): string {
  return UNIT_TYPE_NAMES[unitType] ?? 'Unknown';
}

/**
 * Calculate movement summary from unit data
 */
export function calculateMovementSummary(unit: IBaseUnit): IMovementSummary {
  if (isGroundUnit(unit)) {
    return {
      walkMP: unit.movement.cruiseMP,
      runMP: unit.movement.flankMP,
      jumpMP: unit.movement.jumpMP,
    };
  }

  if (isAerospaceUnit(unit)) {
    return {
      walkMP: 0,
      runMP: 0,
      jumpMP: 0,
      safeThrust: unit.movement.safeThrust,
      maxThrust: unit.movement.maxThrust,
    };
  }

  if (isSquadUnit(unit)) {
    return {
      walkMP: unit.movement.groundMP,
      runMP: Math.ceil(unit.movement.groundMP * 1.5),
      jumpMP: unit.movement.jumpMP,
      umuMP: unit.movement.umuMP,
    };
  }

  // Fallback
  return { walkMP: 0, runMP: 0, jumpMP: 0 };
}

/**
 * Calculate armor/structure summary from unit data
 */
export function calculateArmorStructureSummary(
  unit: IBaseUnit,
  armorTypeName: string = 'Standard',
  structureTypeName: string = 'Standard'
): IArmorStructureSummary {
  if (isGroundUnit(unit)) {
    const armorPercentage =
      unit.maxArmorPoints > 0
        ? Math.round((unit.totalArmorPoints / unit.maxArmorPoints) * 100)
        : 0;

    return {
      totalArmor: unit.totalArmorPoints,
      maxArmor: unit.maxArmorPoints,
      armorPercentage,
      armorType: armorTypeName,
      structureType: structureTypeName,
      totalStructure: 0, // Would need structure data
    };
  }

  if (isAerospaceUnit(unit)) {
    return {
      totalArmor: unit.totalArmorPoints,
      maxArmor: unit.totalArmorPoints, // Aerospace doesn't have max armor concept the same way
      armorPercentage: 100,
      armorType: armorTypeName,
      structureType: structureTypeName,
      totalStructure: 0,
      structuralIntegrity: unit.structuralIntegrity,
    };
  }

  if (isSquadUnit(unit)) {
    const totalArmor = unit.armorPerTrooper * unit.squadSize;
    return {
      totalArmor,
      maxArmor: totalArmor,
      armorPercentage: 100,
      armorType: armorTypeName,
      structureType: 'N/A',
      totalStructure: unit.squadSize, // Squad members as "structure"
    };
  }

  return {
    totalArmor: 0,
    maxArmor: 0,
    armorPercentage: 0,
    armorType: armorTypeName,
    structureType: structureTypeName,
    totalStructure: 0,
  };
}

/**
 * Calculate heat summary from weapons and heat sinks
 */
export function calculateHeatSummary(
  weapons: readonly IWeaponSummary[],
  heatSinkCount: number,
  heatSinkType: 'single' | 'double' = 'single'
): IHeatSummary {
  // Calculate total heat from all weapons
  const totalHeatGenerated = weapons.reduce((sum, w) => sum + w.heat * w.count, 0);

  // Calculate heat dissipation (single = 1/sink, double = 2/sink)
  const dissipationPerSink = heatSinkType === 'double' ? 2 : 1;
  const heatDissipation = heatSinkCount * dissipationPerSink;

  const netHeat = totalHeatGenerated - heatDissipation;

  return {
    totalHeatGenerated,
    heatDissipation,
    netHeat,
    heatSinkType: heatSinkType === 'double' ? 'Double' : 'Single',
    heatSinkCount,
    isHeatNeutral: netHeat <= 0,
  };
}

/**
 * Aggregate weapons by name/type for cleaner display
 */
export function aggregateWeapons(weapons: readonly IWeaponSummary[]): readonly IWeaponSummary[] {
  const aggregated = new Map<string, IWeaponSummary>();

  for (const weapon of weapons) {
    const key = `${weapon.name}-${weapon.location ?? 'none'}-${weapon.isRearMounted ?? false}`;
    const existing = aggregated.get(key);

    if (existing) {
      aggregated.set(key, {
        ...existing,
        count: existing.count + weapon.count,
      });
    } else {
      aggregated.set(key, { ...weapon });
    }
  }

  return Array.from(aggregated.values());
}

/**
 * Format range brackets for display
 */
export function formatRanges(ranges: WeaponRanges): string {
  if (ranges.minimum > 0) {
    return `${ranges.minimum}/${ranges.short}/${ranges.medium}/${ranges.long}`;
  }
  return `${ranges.short}/${ranges.medium}/${ranges.long}`;
}

/**
 * Format damage for display (handles special damage types)
 */
export function formatDamage(damage: number | string): string {
  if (typeof damage === 'number') {
    return damage.toString();
  }
  return damage;
}
